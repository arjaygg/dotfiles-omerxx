#!/usr/bin/env bash

# Stack management script for Charcoal/Graphite workflows

set -o pipefail

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Helper functions
print_header() {
    echo -e "${BOLD}${BLUE}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BOLD}${BLUE}║$(printf '%*s' 28 '')STACK DOCTOR$(printf '%*s' 28 '')║${NC}"
    echo -e "${BOLD}${BLUE}╚════════════════════════════════════════════════════════════╝${NC}"
    echo ""
}

print_section() {
    echo -e "${BOLD}$1${NC}"
}

print_check() {
    echo -n "  Checking $1... "
}

print_done() {
    echo -e "${GREEN}done${NC}"
}

print_error() {
    echo -e "${RED}  ✗ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}  ⚠ $1${NC}"
}

print_success() {
    echo -e "${GREEN}  ✓ $1${NC}"
}

# Main doctor function
run_doctor() {
    local errors=0
    local warnings=0
    local fixes=()

    print_header
    print_section "Running stack integrity checks..."
    echo ""

    # Check 1: Graphite tracked branches that don't exist
    print_check "Graphite branch references"
    if command -v gt &> /dev/null; then
        local tracked_branches=$(gt log short --show-untracked 2>/dev/null | grep -E '^\s*[○●◆]' | sed 's/[○●◆]//; s/^\s*//; s/\s.*$//' || true)
        local missing_branches=()

        while IFS= read -r branch; do
            if [[ -n "$branch" ]] && ! git rev-parse --verify "$branch" &>/dev/null; then
                missing_branches+=("$branch")
            fi
        done <<< "$tracked_branches"

        if [[ ${#missing_branches[@]} -gt 0 ]]; then
            ((errors++))
            for branch in "${missing_branches[@]}"; do
                print_error "Branch '$branch' tracked in Graphite but doesn't exist in git"
                fixes+=("  gt branch untrack $branch")
            done
        fi
    fi
    print_done

    # Check 2: Orphan worktrees
    print_check "for orphan worktrees"
    if git worktree list &>/dev/null; then
        local worktrees=$(git worktree list --porcelain | grep -E '^worktree|^branch' | paste -d' ' - - | sed 's/worktree //; s/branch //')

        while IFS=' ' read -r wt_path wt_branch; do
            if [[ -n "$wt_branch" ]] && [[ "$wt_branch" != "refs/heads/HEAD" ]]; then
                local branch_name="${wt_branch#refs/heads/}"
                if ! git rev-parse --verify "$branch_name" &>/dev/null; then
                    ((warnings++))
                    print_warning "Orphan worktree at '$wt_path' - branch '$branch_name' no longer exists"
                    fixes+=("  git worktree remove '$wt_path' || rm -rf '$wt_path'")
                fi
            fi
        done <<< "$worktrees"
    fi
    print_done

    # Check 3: Unpushed branches
    print_check "remote branches"
    # Skip this check if no remote is configured
    if git remote get-url origin &>/dev/null; then
        # Get local branches (excluding master/main)
        local local_branches=$(git for-each-ref --format='%(refname:short)' refs/heads/ 2>/dev/null | grep -v '^master$' | grep -v '^main$' || true)

        # Check each local branch against remote
        while IFS= read -r branch; do
            if [[ -n "$branch" ]]; then
                # Check if remote tracking branch exists
                if ! git for-each-ref --format='%(refname:short)' "refs/remotes/origin/$branch" 2>/dev/null | grep -q .; then
                    ((warnings++))
                    print_warning "Branch '$branch' exists locally but not pushed to origin"
                    fixes+=("  git push -u origin $branch")
                fi
            fi
        done <<< "$local_branches"
    fi
    print_done

    # Check 4: Branch sync status (branches behind their parent)
    print_check "branch sync status"
    if command -v gt &> /dev/null; then
        # Get the trunk branch
        local trunk=$(git config graphite.trunk 2>/dev/null || echo "master")

        # Check if branches are behind trunk
        local branches=$(git branch --format='%(refname:short)' 2>/dev/null | grep -v "^$trunk$" | grep -v '^master$' | grep -v '^main$' || echo "")

        if [[ -n "$branches" ]]; then
            while IFS= read -r branch; do
                if [[ -n "$branch" ]]; then
                    local behind=$(git rev-list --count "$branch..$trunk" 2>/dev/null || echo "0")
                    if [[ "$behind" -gt 0 ]]; then
                        ((warnings++))
                        print_warning "Branch '$branch' is $behind commit(s) behind '$trunk' - may have merge conflicts"
                        fixes+=("  git checkout $branch && git rebase $trunk")
                    fi
                fi
            done <<< "$branches"
        fi
    fi
    print_done

    # Check 5: Stale branches (merged but not deleted)
    print_check "for stale branches"
    if git remote get-url origin &>/dev/null; then
        # Skip fetch to avoid hanging - check locally merged branches only
        local trunk=$(git config graphite.trunk 2>/dev/null || echo "master")
        local merged_branches=$(git branch --merged "$trunk" 2>/dev/null | grep -v '^\*' | grep -v "$trunk" | grep -v 'main' | grep -v 'master' || true)

        if [[ -n "$merged_branches" ]]; then
            while IFS= read -r branch; do
                branch=$(echo "$branch" | sed 's/^[+* ]*//; s/^[[:space:]]*//; s/[[:space:]]*$//') # trim markers and whitespace
                if [[ -n "$branch" ]]; then
                    ((warnings++))
                    print_warning "Branch '$branch' is merged and can be deleted"
                    fixes+=("  git branch -d $branch")
                fi
            done <<< "$merged_branches"
        fi
    fi
    print_done

    # Check 6: Uncommitted changes
    print_check "for uncommitted changes"
    if ! git diff-index --quiet HEAD -- 2>/dev/null; then
        ((warnings++))
        print_warning "You have uncommitted changes in the current branch"
        fixes+=("  git status  # Review and commit your changes")
    fi
    print_done

    # Check 7: Graphite metadata consistency
    print_check "metadata synchronization"
    if command -v gt &> /dev/null; then
        # Try to run gt log to see if there are any metadata issues
        if ! gt log short --quiet &>/dev/null; then
            ((errors++))
            print_error "Graphite metadata appears to be corrupted"
            fixes+=("  gt repo sync")
        fi
    fi
    print_done

    echo ""
    echo -e "${BOLD}════════════════════════════════════════════════════════════${NC}"
    echo ""

    # Summary
    if [[ $errors -eq 0 ]] && [[ $warnings -eq 0 ]]; then
        print_success "All checks passed! Your stack is healthy."
    else
        if [[ $errors -gt 0 ]]; then
            echo -e "${RED}${BOLD}Errors ($errors):${NC}"
        fi

        if [[ $warnings -gt 0 ]]; then
            echo -e "${YELLOW}${BOLD}Warnings ($warnings):${NC}"
        fi

        if [[ ${#fixes[@]} -gt 0 ]]; then
            echo ""
            echo -e "${BOLD}Suggested fixes:${NC}"
            printf '%s\n' "${fixes[@]}"
        fi

        echo ""
        echo -e "${BOLD}Summary: ${RED}$errors error(s)${NC}${BOLD}, ${YELLOW}$warnings warning(s)${NC}"
    fi
}

# Main command router
main() {
    local command="${1:-}"

    case "$command" in
        doctor)
            run_doctor
            ;;
        *)
            echo "Usage: $0 <command>"
            echo ""
            echo "Commands:"
            echo "  doctor    Run stack health diagnostics"
            exit 1
            ;;
    esac
}

main "$@"
